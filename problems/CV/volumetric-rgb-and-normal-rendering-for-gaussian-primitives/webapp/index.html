<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Volumetric RGB and Normal Rendering for Gaussian Primitives</title>
<style>
:root {
  --bg: #0f1117;
  --surface: #1a1d27;
  --surface2: #242837;
  --accent: #6c8cff;
  --accent2: #4ecdc4;
  --text: #e8eaf0;
  --text2: #9ca3af;
  --border: #2d3248;
  --red: #ff6b6b;
  --green: #51cf66;
  --orange: #ffa94d;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
  background: var(--bg); color: var(--text); line-height: 1.6; overflow-x: hidden;
}
.container { max-width: 1200px; margin: 0 auto; padding: 0 24px; }
.hero {
  background: linear-gradient(135deg, #1a1d27 0%, #0f1117 50%, #162032 100%);
  padding: 80px 0 60px; border-bottom: 1px solid var(--border); position: relative; overflow: hidden;
}
.hero::before {
  content: ''; position: absolute; top: -50%; left: -20%; width: 140%; height: 200%;
  background: radial-gradient(ellipse at 30% 50%, rgba(108,140,255,0.06) 0%, transparent 60%),
              radial-gradient(ellipse at 70% 30%, rgba(78,205,196,0.04) 0%, transparent 50%);
  pointer-events: none;
}
.hero h1 {
  font-size: 2.2rem; font-weight: 700; margin-bottom: 12px; position: relative; z-index: 1;
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.hero .subtitle { font-size: 1.05rem; color: var(--text2); max-width: 720px; margin-bottom: 24px; position: relative; z-index: 1; }
.badge {
  display: inline-block; padding: 4px 12px; border-radius: 20px; font-size: 0.8rem;
  font-weight: 600; margin-right: 8px; margin-bottom: 6px; position: relative; z-index: 1;
}
.badge-blue { background: rgba(108,140,255,0.15); color: var(--accent); border: 1px solid rgba(108,140,255,0.3); }
.badge-green { background: rgba(78,205,196,0.15); color: var(--accent2); border: 1px solid rgba(78,205,196,0.3); }
.badge-orange { background: rgba(255,169,77,0.15); color: var(--orange); border: 1px solid rgba(255,169,77,0.3); }
section { padding: 60px 0; border-bottom: 1px solid var(--border); }
section:last-child { border-bottom: none; }
h2 { font-size: 1.6rem; margin-bottom: 24px; color: var(--text); }
h3 { font-size: 1.15rem; margin-bottom: 16px; color: var(--accent); }
p { color: var(--text2); margin-bottom: 16px; }
.card-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-top: 20px; }
.card {
  background: var(--surface); border: 1px solid var(--border); border-radius: 12px;
  padding: 24px; transition: all 0.2s;
}
.card:hover { border-color: var(--accent); transform: translateY(-2px); }
.card h3 { margin-bottom: 8px; }
.card p { font-size: 0.9rem; }
.math-block {
  background: var(--surface2); border: 1px solid var(--border); border-radius: 10px;
  padding: 20px 24px; margin: 20px 0; font-family: 'Courier New', monospace;
  font-size: 0.95rem; color: var(--accent2); overflow-x: auto; line-height: 1.8;
}
.chart-container {
  background: var(--surface); border: 1px solid var(--border); border-radius: 12px;
  padding: 24px; margin: 20px 0;
}
canvas { max-width: 100%; }
.data-table {
  width: 100%; border-collapse: separate; border-spacing: 0; margin: 20px 0;
  background: var(--surface); border: 1px solid var(--border); border-radius: 12px; overflow: hidden;
}
.data-table th {
  background: var(--surface2); color: var(--accent); font-weight: 600; font-size: 0.85rem;
  text-transform: uppercase; letter-spacing: 0.5px; padding: 14px 16px; text-align: left;
  border-bottom: 1px solid var(--border);
}
.data-table td { padding: 12px 16px; font-size: 0.9rem; color: var(--text2); border-bottom: 1px solid var(--border); }
.data-table tr:last-child td { border-bottom: none; }
.data-table tr:hover td { background: rgba(108,140,255,0.04); }
.data-table .num { font-family: 'Courier New', monospace; color: var(--text); }
.data-table .highlight { color: var(--red); font-weight: 600; }
.tab-bar { display: flex; gap: 4px; background: var(--surface2); border-radius: 10px; padding: 4px; margin-bottom: 24px; width: fit-content; }
.tab-btn {
  padding: 8px 20px; border: none; background: transparent; color: var(--text2);
  font-size: 0.9rem; font-weight: 500; border-radius: 8px; cursor: pointer; transition: all 0.2s;
}
.tab-btn.active { background: var(--accent); color: white; }
.tab-btn:hover:not(.active) { background: rgba(108,140,255,0.1); color: var(--text); }
.tab-content { display: none; }
.tab-content.active { display: block; }
.bar-chart { display: flex; flex-direction: column; gap: 12px; margin: 20px 0; }
.bar-row { display: flex; align-items: center; gap: 12px; }
.bar-label { width: 110px; font-size: 0.85rem; color: var(--text2); text-align: right; flex-shrink: 0; }
.bar-track { flex: 1; height: 28px; background: var(--surface2); border-radius: 6px; overflow: hidden; position: relative; }
.bar-fill {
  height: 100%; border-radius: 6px; transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
  display: flex; align-items: center; padding-left: 10px; font-size: 0.8rem; font-weight: 600; color: white;
}
.bar-value { width: 80px; font-family: 'Courier New', monospace; font-size: 0.85rem; color: var(--text); text-align: right; flex-shrink: 0; }
.pipeline { display: flex; align-items: center; gap: 0; overflow-x: auto; padding: 20px 0; }
.pipeline-step {
  background: var(--surface); border: 2px solid var(--border); border-radius: 10px;
  padding: 16px 20px; min-width: 160px; text-align: center; transition: all 0.3s; flex-shrink: 0;
}
.pipeline-step:hover { border-color: var(--accent); }
.pipeline-step .step-num { font-size: 0.75rem; color: var(--accent); font-weight: 700; margin-bottom: 4px; }
.pipeline-step .step-title { font-size: 0.9rem; font-weight: 600; color: var(--text); }
.pipeline-step .step-desc { font-size: 0.75rem; color: var(--text2); margin-top: 4px; }
.pipeline-arrow { font-size: 1.4rem; color: var(--accent); padding: 0 8px; flex-shrink: 0; }
.slider-group { margin: 20px 0; }
.slider-group label { display: block; font-size: 0.9rem; color: var(--text2); margin-bottom: 8px; }
.slider-group input[type="range"] { width: 100%; accent-color: var(--accent); }
footer {
  padding: 40px 0; text-align: center; color: var(--text2); font-size: 0.85rem;
  border-top: 1px solid var(--border);
}
footer a { color: var(--accent); text-decoration: none; }
footer a:hover { text-decoration: underline; }
@media (max-width: 768px) {
  .hero h1 { font-size: 1.6rem; }
  .card-grid { grid-template-columns: 1fr; }
  .pipeline { flex-direction: column; }
  .pipeline-arrow { transform: rotate(90deg); }
}
</style>
</head>
<body>

<header class="hero">
<div class="container">
  <span class="badge badge-blue">KDD 2026</span>
  <span class="badge badge-green">Computer Vision</span>
  <span class="badge badge-orange">Gaussian Splatting</span>
  <h1>Fully Volumetric RGB and Normal Rendering for Gaussian Primitives</h1>
  <p class="subtitle">
    Extending the stochastic-solid attenuation model to unified volumetric integration
    of color, normals, depth, and opacity for 3D Gaussian Splatting.
  </p>
</div>
</header>

<section>
<div class="container">
  <h2>The Problem</h2>
  <p>3D Gaussian Splatting (3DGS) renders scenes by projecting 3D Gaussians to 2D and alpha-compositing in screen space.
     Zhang et al. (2026) introduced a stochastic-solid model for volumetric depth rendering, but RGB and normals still
     use the splatting approximation. This creates inconsistency between channels.</p>
  <div class="card-grid">
    <div class="card">
      <h3>Popping Artifacts</h3>
      <p>Depth ordering of overlapping Gaussians can flip with viewpoint changes, causing color and normal discontinuities.</p>
    </div>
    <div class="card">
      <h3>Depth-Color Mismatch</h3>
      <p>When depth is volumetric but color is splatted, the implied surfaces disagree, producing blurry or misaligned normals.</p>
    </div>
    <div class="card">
      <h3>Normal Estimation Bias</h3>
      <p>Splatting approximates Gaussians as planar ellipses, losing 3D volumetric extent that should influence normals.</p>
    </div>
  </div>
</div>
</section>

<section>
<div class="container">
  <h2>Our Approach</h2>
  <p>We derive and implement fully volumetric rendering integrals for all output channels under the stochastic-solid transmittance model.</p>
  <h3>Rendering Pipeline</h3>
  <div class="pipeline">
    <div class="pipeline-step">
      <div class="step-num">STEP 1</div>
      <div class="step-title">Ray-Gaussian Projection</div>
      <div class="step-desc">3D Gaussian reduces to 1D along ray</div>
    </div>
    <div class="pipeline-arrow">&rarr;</div>
    <div class="pipeline-step">
      <div class="step-num">STEP 2</div>
      <div class="step-title">Importance Sampling</div>
      <div class="step-desc">Quadrature near Gaussian peaks</div>
    </div>
    <div class="pipeline-arrow">&rarr;</div>
    <div class="pipeline-step">
      <div class="step-num">STEP 3</div>
      <div class="step-title">Stochastic-Solid Transmittance</div>
      <div class="step-desc">T(t) = &prod; [1 - &alpha;G(r(t))]</div>
    </div>
    <div class="pipeline-arrow">&rarr;</div>
    <div class="pipeline-step">
      <div class="step-num">STEP 4</div>
      <div class="step-title">Volumetric Integration</div>
      <div class="step-desc">Color, normals, depth, opacity</div>
    </div>
  </div>
  <h3 style="margin-top:30px">Key Equations</h3>
  <div class="math-block">
    <strong>Stochastic-Solid Transmittance:</strong><br>
    T(t) = &prod;<sub>i</sub> [1 - &alpha;<sub>i</sub> &middot; G<sub>i</sub>(r(t))]<br><br>
    <strong>Volumetric Color Integral:</strong><br>
    C = &int; [-dT/dt] &middot; c(t) dt<br><br>
    <strong>Volumetric Normal (from density gradient):</strong><br>
    N = normalize( &int; [-dT/dt] &middot; n(r(t)) dt )<br>
    where n(x) = -&nabla;&rho;(x) / |&nabla;&rho;(x)|<br><br>
    <strong>Closed-Form 1D Ray Parameter:</strong><br>
    G<sub>i</sub>(r(t)) = p<sub>i</sub> &middot; exp(-(t - t<sub>&mu;,i</sub>)&sup2; / 2&sigma;<sub>t,i</sub>&sup2;)
  </div>
</div>
</section>

<section>
<div class="container">
  <h2>Experimental Results</h2>
  <div class="tab-bar" id="tabbar"></div>

  <div id="tab-divergence" class="tab-content active">
    <h3>Volumetric vs. Splatting Divergence</h3>
    <p>The two methods produce substantially different outputs. The Dense scene with 25 Gaussians shows the largest divergence.</p>
    <div class="slider-group">
      <label>Select Scene: <strong id="scene-label">Dense (25 Gaussians)</strong></label>
      <input type="range" id="scene-slider" min="0" max="4" value="2">
    </div>
    <div id="divergence-bars" class="bar-chart"></div>
    <table class="data-table">
      <thead><tr><th>Scene</th><th># Gaussians</th><th>RGB RMSE</th><th>Normal MAE (deg)</th><th>Depth RMSE</th><th>Opacity RMSE</th></tr></thead>
      <tbody>
        <tr><td>Simple</td><td class="num">5</td><td class="num">0.293</td><td class="num highlight">60.5</td><td class="num">0.832</td><td class="num">0.421</td></tr>
        <tr><td>Moderate</td><td class="num">12</td><td class="num">0.330</td><td class="num highlight">62.4</td><td class="num">0.730</td><td class="num">0.551</td></tr>
        <tr><td>Dense</td><td class="num">25</td><td class="num highlight">0.486</td><td class="num highlight">65.6</td><td class="num">0.806</td><td class="num highlight">0.762</td></tr>
        <tr><td>Anisotropic</td><td class="num">10</td><td class="num">0.393</td><td class="num highlight">57.4</td><td class="num">0.746</td><td class="num">0.643</td></tr>
        <tr><td>Deep Overlap</td><td class="num">8</td><td class="num">0.330</td><td class="num">---</td><td class="num">---</td><td class="num">0.514</td></tr>
      </tbody>
    </table>
  </div>

  <div id="tab-convergence" class="tab-content">
    <h3>Quadrature Convergence</h3>
    <p>Volumetric rendering converges rapidly with increasing quadrature samples. Even 8 samples dramatically outperform splatting.</p>
    <div class="chart-container"><canvas id="convergence-chart" width="800" height="350"></canvas></div>
    <table class="data-table">
      <thead><tr><th>Samples</th><th>RGB RMSE (vs ref)</th><th>Normal MAE (deg)</th><th>Time (s)</th></tr></thead>
      <tbody>
        <tr><td class="num">8</td><td class="num">1.38e-4</td><td class="num">11.74</td><td class="num">5.20</td></tr>
        <tr><td class="num">16</td><td class="num">6.99e-5</td><td class="num">5.16</td><td class="num">5.50</td></tr>
        <tr><td class="num">32</td><td class="num">4.17e-5</td><td class="num">1.94</td><td class="num">5.15</td></tr>
        <tr><td class="num">48</td><td class="num">2.47e-5</td><td class="num">1.42</td><td class="num">5.58</td></tr>
        <tr><td class="num">64</td><td class="num">1.18e-5</td><td class="num">0.74</td><td class="num">6.50</td></tr>
        <tr><td class="num">96</td><td class="num">5.95e-6</td><td class="num">0.34</td><td class="num">6.39</td></tr>
        <tr><td class="num">128</td><td class="num">2.80e-6</td><td class="num">0.22</td><td class="num">5.87</td></tr>
        <tr style="background:rgba(255,107,107,0.08)"><td>Splatting</td><td class="num highlight">0.329</td><td class="num highlight">64.0</td><td class="num">---</td></tr>
      </tbody>
    </table>
  </div>

  <div id="tab-timing" class="tab-content">
    <h3>Render Time Comparison</h3>
    <p>Volumetric rendering is competitive with splatting, and actually faster for dense scenes.</p>
    <div class="chart-container"><canvas id="timing-chart" width="800" height="350"></canvas></div>
    <table class="data-table">
      <thead><tr><th>Scene</th><th>Volumetric (s)</th><th>Splatting (s)</th><th>Ratio</th></tr></thead>
      <tbody>
        <tr><td>Simple</td><td class="num">4.6</td><td class="num">3.8</td><td class="num">1.23x</td></tr>
        <tr><td>Moderate</td><td class="num">7.9</td><td class="num">8.4</td><td class="num" style="color:var(--green)">0.94x</td></tr>
        <tr><td>Dense</td><td class="num">10.3</td><td class="num">14.2</td><td class="num" style="color:var(--green)">0.72x</td></tr>
        <tr><td>Anisotropic</td><td class="num">8.9</td><td class="num">10.3</td><td class="num" style="color:var(--green)">0.87x</td></tr>
        <tr><td>Deep Overlap</td><td class="num">7.6</td><td class="num">7.1</td><td class="num">1.07x</td></tr>
      </tbody>
    </table>
  </div>
</div>
</section>

<section>
<div class="container">
  <h2>Key Findings</h2>
  <div class="card-grid">
    <div class="card">
      <h3 style="color:var(--red)">RGB RMSE up to 0.486</h3>
      <p>Volumetric and splatting renderings diverge substantially in dense, highly overlapping configurations.</p>
    </div>
    <div class="card">
      <h3 style="color:var(--orange)">Normal error exceeds 65 degrees</h3>
      <p>Splatting produces fundamentally different normal fields by evaluating normals at projected centers only.</p>
    </div>
    <div class="card">
      <h3 style="color:var(--green)">Sub-degree accuracy at 64 samples</h3>
      <p>Quadrature converges rapidly: 64 samples achieve 0.74-degree normal accuracy vs. splatting's 64-degree error.</p>
    </div>
    <div class="card">
      <h3 style="color:var(--accent)">Fully differentiable</h3>
      <p>Gradients flow through quadrature, transmittance, and density-gradient normals for end-to-end optimization.</p>
    </div>
  </div>
</div>
</section>

<section>
<div class="container">
  <h2>References</h2>
  <p style="font-size:0.9rem">[1] Zhang et al. "Geometry-Grounded Gaussian Splatting." arXiv:2601.17835, Jan 2026.</p>
  <p style="font-size:0.9rem">[2] Kerbl et al. "3D Gaussian Splatting for Real-Time Radiance Field Rendering." ACM TOG, 2023.</p>
  <p style="font-size:0.9rem">[3] Mildenhall et al. "NeRF: Representing Scenes as Neural Radiance Fields." ECCV 2020.</p>
  <p style="font-size:0.9rem">[4] Huang et al. "2D Gaussian Splatting for Geometrically Accurate Radiance Fields." ACM TOG, 2024.</p>
  <p style="font-size:0.9rem">[5] Max. "Optical Models for Direct Volume Rendering." IEEE TVCG, 1995.</p>
</div>
</section>

<footer>
<div class="container">
  <p>Volumetric RGB and Normal Rendering for Gaussian Primitives &mdash; KDD 2026 Research Track</p>
  <p style="margin-top:8px">Based on the open problem from <a href="https://www.emergentmind.com/open-problems/volumetric-rgb-and-normal-rendering-for-gaussian-primitives" target="_blank">EmergentMind</a></p>
</div>
</footer>

<script>
// Data from actual experiment runs
var sceneData = [
  { name: "Simple", n: 5, rgb: 0.293, normal: 60.5, depth: 0.832, opacity: 0.421 },
  { name: "Moderate", n: 12, rgb: 0.330, normal: 62.4, depth: 0.730, opacity: 0.551 },
  { name: "Dense", n: 25, rgb: 0.486, normal: 65.6, depth: 0.806, opacity: 0.762 },
  { name: "Anisotropic", n: 10, rgb: 0.393, normal: 57.4, depth: 0.746, opacity: 0.643 },
  { name: "Deep Overlap", n: 8, rgb: 0.330, normal: 0, depth: 0, opacity: 0.514 }
];

var convergenceNormal = [11.74, 5.16, 3.31, 1.94, 1.42, 0.74, 0.34, 0.22];
var convergenceSamples = [8, 16, 24, 32, 48, 64, 96, 128];
var splatNormal = 64.0;

var timingScenes = ["Simple", "Moderate", "Dense", "Aniso.", "Deep Ov."];
var timingVol = [4.6, 7.9, 10.3, 8.9, 7.6];
var timingSplat = [3.8, 8.4, 14.2, 10.3, 7.1];

// Tab setup
(function() {
  var tabbar = document.getElementById('tabbar');
  var tabNames = [
    {id: 'divergence', label: 'Divergence'},
    {id: 'convergence', label: 'Convergence'},
    {id: 'timing', label: 'Timing'}
  ];
  tabNames.forEach(function(t) {
    var btn = document.createElement('button');
    btn.className = 'tab-btn' + (t.id === 'divergence' ? ' active' : '');
    btn.textContent = t.label;
    btn.setAttribute('data-tab', t.id);
    btn.addEventListener('click', function() {
      document.querySelectorAll('.tab-content').forEach(function(el) { el.classList.remove('active'); });
      document.querySelectorAll('.tab-btn').forEach(function(el) { el.classList.remove('active'); });
      document.getElementById('tab-' + t.id).classList.add('active');
      btn.classList.add('active');
      if (t.id === 'convergence') drawConvergenceChart();
      if (t.id === 'timing') drawTimingChart();
    });
    tabbar.appendChild(btn);
  });
})();

// Scene slider
document.getElementById('scene-slider').addEventListener('input', function() {
  updateScene(parseInt(this.value));
});

function updateScene(val) {
  var s = sceneData[val];
  document.getElementById('scene-label').textContent = s.name + ' (' + s.n + ' Gaussians)';
  renderBars(s);
}

function renderBars(s) {
  var container = document.getElementById('divergence-bars');
  while (container.firstChild) container.removeChild(container.firstChild);

  var metrics = [
    {label: 'RGB RMSE', value: s.rgb, max: 0.5, color: 'linear-gradient(90deg,#2196F3,#6c8cff)', fmt: s.rgb.toFixed(4)},
    {label: 'Normal MAE', value: s.normal, max: 70, color: 'linear-gradient(90deg,#E91E63,#ff6b6b)', fmt: s.normal > 0 ? s.normal.toFixed(1) + ' deg' : '---'},
    {label: 'Depth RMSE', value: s.depth, max: 1.0, color: 'linear-gradient(90deg,#4CAF50,#51cf66)', fmt: s.depth > 0 ? s.depth.toFixed(4) : '---'},
    {label: 'Opacity RMSE', value: s.opacity, max: 0.8, color: 'linear-gradient(90deg,#FF9800,#ffa94d)', fmt: s.opacity.toFixed(4)}
  ];

  metrics.forEach(function(m) {
    var row = document.createElement('div');
    row.className = 'bar-row';

    var lbl = document.createElement('div');
    lbl.className = 'bar-label';
    lbl.textContent = m.label;

    var track = document.createElement('div');
    track.className = 'bar-track';

    var fill = document.createElement('div');
    fill.className = 'bar-fill';
    var pct = m.value > 0 ? (m.value / m.max) * 100 : 0;
    fill.style.width = Math.min(pct, 100) + '%';
    fill.style.background = m.color;
    fill.textContent = m.value > 0 ? m.fmt : '---';

    var val = document.createElement('div');
    val.className = 'bar-value';
    val.textContent = m.fmt;

    track.appendChild(fill);
    row.appendChild(lbl);
    row.appendChild(track);
    row.appendChild(val);
    container.appendChild(row);
  });
}

function drawConvergenceChart() {
  var canvas = document.getElementById('convergence-chart');
  if (!canvas) return;
  var ctx = canvas.getContext('2d');
  var W = canvas.width, H = canvas.height;
  var pad = {l: 60, r: 20, t: 30, b: 40};
  var pw = W - pad.l - pad.r, ph = H - pad.t - pad.b;
  var maxN = 70;

  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#1a1d27';
  ctx.fillRect(0, 0, W, H);

  // Grid
  ctx.strokeStyle = 'rgba(255,255,255,0.05)';
  ctx.lineWidth = 1;
  for (var gi = 0; gi <= 5; gi++) {
    var gy = pad.t + (gi / 5) * ph;
    ctx.beginPath(); ctx.moveTo(pad.l, gy); ctx.lineTo(pad.l + pw, gy); ctx.stroke();
  }

  // Splatting baseline
  var splatY = pad.t + (1 - splatNormal / maxN) * ph;
  ctx.strokeStyle = '#ff6b6b'; ctx.lineWidth = 2;
  ctx.setLineDash([8, 4]);
  ctx.beginPath(); ctx.moveTo(pad.l, splatY); ctx.lineTo(pad.l + pw, splatY); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = '#ff6b6b'; ctx.font = '12px sans-serif';
  ctx.fillText('Splatting: 64.0 deg', pad.l + pw - 140, splatY - 8);

  // Volumetric line
  ctx.strokeStyle = '#4ecdc4'; ctx.lineWidth = 3; ctx.beginPath();
  convergenceSamples.forEach(function(s, i) {
    var x = pad.l + (i / (convergenceSamples.length - 1)) * pw;
    var y = pad.t + (1 - convergenceNormal[i] / maxN) * ph;
    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
  });
  ctx.stroke();

  // Points and labels
  convergenceSamples.forEach(function(s, i) {
    var x = pad.l + (i / (convergenceSamples.length - 1)) * pw;
    var y = pad.t + (1 - convergenceNormal[i] / maxN) * ph;
    ctx.fillStyle = '#4ecdc4';
    ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#9ca3af'; ctx.font = '11px monospace'; ctx.textAlign = 'center';
    ctx.fillText(s.toString(), x, pad.t + ph + 20);
    if (convergenceNormal[i] < 15) {
      ctx.fillStyle = '#e8eaf0';
      ctx.fillText(convergenceNormal[i].toFixed(1) + ' deg', x, y - 12);
    }
  });

  // Axes
  ctx.fillStyle = '#9ca3af'; ctx.font = '12px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('Quadrature Samples', pad.l + pw / 2, H - 5);
  ctx.save(); ctx.translate(15, pad.t + ph / 2); ctx.rotate(-Math.PI / 2);
  ctx.fillText('Normal MAE (degrees)', 0, 0); ctx.restore();
  ctx.textAlign = 'right';
  for (var yi = 0; yi <= 5; yi++) {
    var yval = (yi / 5) * maxN;
    var yy = pad.t + (1 - yval / maxN) * ph;
    ctx.fillText(yval.toFixed(0), pad.l - 8, yy + 4);
  }
  ctx.fillStyle = '#e8eaf0'; ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('Normal Accuracy vs. Quadrature Samples', W / 2, 18);
}

function drawTimingChart() {
  var canvas = document.getElementById('timing-chart');
  if (!canvas) return;
  var ctx = canvas.getContext('2d');
  var W = canvas.width, H = canvas.height;
  var pad = {l: 60, r: 20, t: 30, b: 50};
  var pw = W - pad.l - pad.r, ph = H - pad.t - pad.b;
  var maxT = 16;
  var groupW = pw / timingScenes.length;
  var barW = groupW * 0.35;

  ctx.clearRect(0, 0, W, H);
  ctx.fillStyle = '#1a1d27';
  ctx.fillRect(0, 0, W, H);

  timingScenes.forEach(function(name, i) {
    var gx = pad.l + i * groupW + groupW / 2;
    var vh = (timingVol[i] / maxT) * ph;
    ctx.fillStyle = '#6c8cff';
    ctx.fillRect(gx - barW - 2, pad.t + ph - vh, barW, vh);
    var sh = (timingSplat[i] / maxT) * ph;
    ctx.fillStyle = '#ff6b6b';
    ctx.fillRect(gx + 2, pad.t + ph - sh, barW, sh);
    ctx.fillStyle = '#9ca3af'; ctx.font = '11px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText(name, gx, pad.t + ph + 20);
    ctx.font = '10px monospace';
    ctx.fillStyle = '#6c8cff';
    ctx.fillText(timingVol[i].toFixed(1) + 's', gx - barW / 2 - 2, pad.t + ph - vh - 5);
    ctx.fillStyle = '#ff6b6b';
    ctx.fillText(timingSplat[i].toFixed(1) + 's', gx + barW / 2 + 2, pad.t + ph - sh - 5);
  });

  // Legend
  ctx.fillStyle = '#6c8cff'; ctx.fillRect(pad.l + pw - 200, 8, 12, 12);
  ctx.fillStyle = '#e8eaf0'; ctx.font = '12px sans-serif'; ctx.textAlign = 'left';
  ctx.fillText('Volumetric', pad.l + pw - 184, 18);
  ctx.fillStyle = '#ff6b6b'; ctx.fillRect(pad.l + pw - 100, 8, 12, 12);
  ctx.fillStyle = '#e8eaf0'; ctx.fillText('Splatting', pad.l + pw - 84, 18);

  ctx.fillStyle = '#9ca3af'; ctx.textAlign = 'right';
  for (var ti = 0; ti <= 4; ti++) {
    var tval = (ti / 4) * maxT;
    var ty = pad.t + ph - (tval / maxT) * ph;
    ctx.fillText(tval.toFixed(0) + 's', pad.l - 8, ty + 4);
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.beginPath(); ctx.moveTo(pad.l, ty); ctx.lineTo(pad.l + pw, ty); ctx.stroke();
  }
  ctx.fillStyle = '#e8eaf0'; ctx.font = 'bold 14px sans-serif'; ctx.textAlign = 'center';
  ctx.fillText('Render Time: Volumetric vs. Splatting (48x48)', W / 2, pad.t - 10);
}

// Initialize
updateScene(2);
</script>
</body>
</html>
