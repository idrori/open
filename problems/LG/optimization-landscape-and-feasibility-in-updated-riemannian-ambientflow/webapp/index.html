<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Optimization Landscape and Feasibility in Riemannian AmbientFlow</title>
<style>
:root {
  --bg: #0f1117;
  --card: #1a1d28;
  --border: #2a2d3a;
  --text: #e4e6ed;
  --muted: #8b8fa3;
  --accent: #6c63ff;
  --accent2: #ff6b6b;
  --accent3: #4ecdc4;
  --accent4: #ffe66d;
}
* { margin:0; padding:0; box-sizing:border-box; }
body {
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  background: var(--bg);
  color: var(--text);
  line-height: 1.6;
}
.container { max-width: 1200px; margin: 0 auto; padding: 0 24px; }

/* Header */
header {
  background: linear-gradient(135deg, #1a1d28 0%, #252838 100%);
  border-bottom: 1px solid var(--border);
  padding: 40px 0 30px;
}
header h1 {
  font-size: 1.8rem;
  font-weight: 700;
  margin-bottom: 8px;
  background: linear-gradient(135deg, var(--accent), var(--accent3));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}
header .subtitle {
  color: var(--muted);
  font-size: 0.95rem;
  max-width: 800px;
}
header .meta {
  display: flex;
  gap: 16px;
  margin-top: 12px;
  font-size: 0.82rem;
  color: var(--muted);
}
header .meta span {
  background: rgba(108,99,255,0.15);
  padding: 3px 10px;
  border-radius: 12px;
  border: 1px solid rgba(108,99,255,0.25);
}

/* Nav */
nav {
  background: var(--card);
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  z-index: 100;
}
nav .container {
  display: flex;
  gap: 4px;
  overflow-x: auto;
  padding: 8px 24px;
}
nav button {
  background: transparent;
  color: var(--muted);
  border: none;
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.85rem;
  white-space: nowrap;
  transition: all 0.2s;
}
nav button:hover { color: var(--text); background: rgba(255,255,255,0.05); }
nav button.active { color: var(--accent); background: rgba(108,99,255,0.12); }

/* Sections */
section { padding: 32px 0; display: none; }
section.active { display: block; }

.card {
  background: var(--card);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 24px;
  margin-bottom: 20px;
}
.card h2 {
  font-size: 1.2rem;
  margin-bottom: 12px;
  color: var(--accent3);
}
.card h3 {
  font-size: 1rem;
  margin: 16px 0 8px;
  color: var(--accent);
}
.card p { color: var(--muted); font-size: 0.9rem; margin-bottom: 10px; }

/* Math/equation styling */
.equation {
  background: rgba(108,99,255,0.08);
  border: 1px solid rgba(108,99,255,0.2);
  border-radius: 8px;
  padding: 14px 20px;
  margin: 12px 0;
  font-family: 'Cambria Math', 'Times New Roman', serif;
  font-size: 1.05rem;
  text-align: center;
  color: var(--text);
}

/* Controls */
.controls {
  display: flex;
  gap: 16px;
  flex-wrap: wrap;
  margin-bottom: 16px;
  align-items: center;
}
.controls label {
  font-size: 0.82rem;
  color: var(--muted);
}
.controls select, .controls input[type="range"] {
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 6px 10px;
  font-size: 0.85rem;
}
.controls select { cursor: pointer; }
.controls input[type="range"] { width: 180px; }
.range-val {
  font-size: 0.82rem;
  color: var(--accent);
  min-width: 40px;
}

/* Chart */
.chart-container {
  position: relative;
  width: 100%;
  margin: 12px 0;
}
canvas {
  width: 100% !important;
  height: auto !important;
  border-radius: 8px;
}

/* Grid */
.grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
.grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; }
@media (max-width: 768px) {
  .grid-2, .grid-3 { grid-template-columns: 1fr; }
}

/* Stat */
.stat-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 12px;
  margin: 12px 0;
}
.stat {
  background: rgba(108,99,255,0.08);
  border: 1px solid rgba(108,99,255,0.15);
  border-radius: 8px;
  padding: 12px;
  text-align: center;
}
.stat .val {
  font-size: 1.4rem;
  font-weight: 700;
  color: var(--accent);
}
.stat .lbl {
  font-size: 0.75rem;
  color: var(--muted);
  margin-top: 4px;
}

/* Table */
table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.82rem;
  margin: 12px 0;
}
th, td {
  padding: 8px 10px;
  text-align: center;
  border-bottom: 1px solid var(--border);
}
th {
  color: var(--accent);
  font-weight: 600;
  background: rgba(108,99,255,0.08);
}
td { color: var(--muted); }
tr:hover td { color: var(--text); background: rgba(255,255,255,0.02); }

/* Key finding */
.finding {
  border-left: 3px solid var(--accent);
  padding: 10px 16px;
  margin: 12px 0;
  background: rgba(108,99,255,0.05);
  border-radius: 0 8px 8px 0;
}
.finding strong { color: var(--accent3); }

.tag {
  display: inline-block;
  background: rgba(78,205,196,0.15);
  color: var(--accent3);
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 0.72rem;
  margin-right: 4px;
}
.tag.warn {
  background: rgba(255,107,107,0.15);
  color: var(--accent2);
}

footer {
  border-top: 1px solid var(--border);
  padding: 20px 0;
  text-align: center;
  font-size: 0.78rem;
  color: var(--muted);
}
</style>
</head>
<body>

<header>
  <div class="container">
    <h1>Optimization Landscape &amp; Feasibility in Riemannian AmbientFlow</h1>
    <p class="subtitle">An empirical investigation of the open problem: which local minima are reached, and do the recoverability theorem's feasibility assumptions hold at those minima?</p>
    <div class="meta">
      
      <span>cs.LG - Machine Learning</span>
      <span>Based on arXiv:2601.18728</span>
    </div>
  </div>
</header>

<nav>
  <div class="container">
    <button class="active" onclick="showSection('overview')">Overview</button>
    <button onclick="showSection('landscape')">Landscape</button>
    <button onclick="showSection('feasibility')">Feasibility</button>
    <button onclick="showSection('hessian')">Hessian</button>
    <button onclick="showSection('continuation')">Continuation</button>
    <button onclick="showSection('geometry')">Geometry</button>
    <button onclick="showSection('findings')">Key Findings</button>
  </div>
</nav>

<div class="container">

<!-- OVERVIEW -->
<section id="overview" class="active">
  <div class="card">
    <h2>Problem Statement</h2>
    <p>Riemannian AmbientFlow minimizes a combined objective with a variational lower bound and geometric regularization:</p>
    <div class="equation">
      L(&theta;, &phi;) = L<sub>AmbientFlow</sub>(&theta;, &phi;) + &lambda; &middot; |J<sub>f<sub>&theta;</sub></sub>(0)|<sub>F</sub><sup>2</sup>
    </div>
    <p>The recoverability theorem requires three <strong>feasibility assumptions</strong>:</p>
    <div class="finding"><strong>(F1) Data matching:</strong> The learned data distribution equals the ground truth.</div>
    <div class="finding"><strong>(F2) Posterior matching:</strong> The variational posterior equals the true posterior.</div>
    <div class="finding"><strong>(F3) Geometric constraint:</strong> The Jacobian Frobenius norm at the origin is bounded.</div>
    <p>The open question: do gradient-based optimizers find local minima that satisfy all three conditions?</p>
  </div>

  <div class="grid-3">
    <div class="card">
      <h3>Circle in R<sup>2</sup></h3>
      <p>Unit circle S<sup>1</sup> parameterized by f*(z) = (cos z, sin z). Intrinsic dim d=1, ambient dim D=2.</p>
      <div class="stat"><div class="val">1 &rarr; 2</div><div class="lbl">d &rarr; D</div></div>
    </div>
    <div class="card">
      <h3>Sphere in R<sup>3</sup></h3>
      <p>Unit sphere S<sup>2</sup> via inverse stereographic projection. Intrinsic dim d=2, ambient dim D=3.</p>
      <div class="stat"><div class="val">2 &rarr; 3</div><div class="lbl">d &rarr; D</div></div>
    </div>
    <div class="card">
      <h3>Helix in R<sup>3</sup></h3>
      <p>Helix f*(t) = (cos t, sin t, t/2&pi;). Intrinsic dim d=1, ambient dim D=3.</p>
      <div class="stat"><div class="val">1 &rarr; 3</div><div class="lbl">d &rarr; D</div></div>
    </div>
  </div>

  <div class="card">
    <h2>Experimental Setup</h2>
    <div class="stat-grid">
      <div class="stat"><div class="val">200</div><div class="lbl">Data Points</div></div>
      <div class="stat"><div class="val">10</div><div class="lbl">Random Starts</div></div>
      <div class="stat"><div class="val">7</div><div class="lbl">&lambda; Values</div></div>
      <div class="stat"><div class="val">200</div><div class="lbl">L-BFGS-B Iters</div></div>
      <div class="stat"><div class="val">0.1</div><div class="lbl">Noise &sigma;</div></div>
      <div class="stat"><div class="val">4</div><div class="lbl">Experiments</div></div>
    </div>
  </div>
</section>

<!-- LANDSCAPE -->
<section id="landscape">
  <div class="card">
    <h2>Experiment 1: Multi-Start Landscape Exploration</h2>
    <p>Objective value across 10 random initializations for each &lambda;. High variance indicates multiple distinct local minima.</p>
    <div class="controls">
      <label>Manifold:</label>
      <select id="land-manifold" onchange="renderLandscape()">
        <option value="Circle_in_R2">Circle in R2</option>
        <option value="Sphere_in_R3">Sphere in R3</option>
        <option value="Helix_in_R3">Helix in R3</option>
      </select>
      <label>Metric:</label>
      <select id="land-metric" onchange="renderLandscape()">
        <option value="obj">Objective</option>
        <option value="jac">Jacobian Norm</option>
        <option value="feas">Feasibility</option>
      </select>
    </div>
    <div class="chart-container">
      <canvas id="chartLandscape" width="800" height="350"></canvas>
    </div>
  </div>

  <div class="card">
    <h2>Objective Spread (Landscape Complexity)</h2>
    <p>Standard deviation of the converged objective across starts. Higher spread indicates more distinct local minima.</p>
    <table>
      <tr><th>&lambda;</th><th>Circle (std)</th><th>Sphere (std)</th><th>Helix (std)</th></tr>
      <tr><td>0.00</td><td>1.837</td><td>0.160</td><td>2.083</td></tr>
      <tr><td>0.01</td><td>1.208</td><td>0.128</td><td>1.823</td></tr>
      <tr><td>0.05</td><td>1.208</td><td>0.117</td><td>1.379</td></tr>
      <tr><td>0.10</td><td>1.624</td><td>0.133</td><td>0.058</td></tr>
      <tr><td>0.50</td><td>1.198</td><td>0.143</td><td>0.031</td></tr>
      <tr><td>1.00</td><td>1.202</td><td>0.187</td><td>1.391</td></tr>
      <tr><td>2.00</td><td>1.606</td><td>0.281</td><td>0.048</td></tr>
    </table>
    <div class="finding"><strong>Key insight:</strong> The sphere has consistently low objective spread (&lt;0.28), suggesting a simpler landscape. The circle and helix show spreads exceeding 1.8, indicating multiple well-separated basins.</div>
  </div>
</section>

<!-- FEASIBILITY -->
<section id="feasibility">
  <div class="card">
    <h2>Experiment 2: Feasibility Phase Diagram</h2>
    <p>Aggregate feasibility score combining data matching (F1), posterior matching (F2), and geometric constraint (F3).</p>
    <div class="controls">
      <label>Manifold:</label>
      <select id="feas-manifold" onchange="renderFeasibility()">
        <option value="Circle_in_R2">Circle in R2</option>
        <option value="Sphere_in_R3">Sphere in R3</option>
        <option value="Helix_in_R3">Helix in R3</option>
      </select>
    </div>
    <div class="chart-container">
      <canvas id="chartFeasibility" width="800" height="350"></canvas>
    </div>
  </div>

  <div class="card">
    <h2>Feasibility Decomposition</h2>
    <p>Breaking down the aggregate score into its three components reveals the fundamental trade-off.</p>
    <div class="controls">
      <label>Manifold:</label>
      <select id="decomp-manifold" onchange="renderDecomp()">
        <option value="Circle_in_R2">Circle in R2</option>
        <option value="Sphere_in_R3">Sphere in R3</option>
        <option value="Helix_in_R3">Helix in R3</option>
      </select>
    </div>
    <div class="chart-container">
      <canvas id="chartDecomp" width="800" height="350"></canvas>
    </div>
    <div class="finding"><strong>Trade-off:</strong> Increasing &lambda; improves the geometric constraint (F3) but degrades data matching (F1). The aggregate feasibility is non-monotonic with a manifold-dependent sweet spot. No configuration achieves near-perfect feasibility (&gt;0.9).</div>
  </div>
</section>

<!-- HESSIAN -->
<section id="hessian">
  <div class="card">
    <h2>Experiment 3: Hessian Spectral Analysis</h2>
    <p>Distribution of directional second derivatives at converged critical points. All positive curvature confirms genuine local minima.</p>
    <div class="controls">
      <label>Manifold:</label>
      <select id="hess-manifold" onchange="renderHessian()">
        <option value="Circle_in_R2">Circle in R2</option>
        <option value="Sphere_in_R3">Sphere in R3</option>
        <option value="Helix_in_R3">Helix in R3</option>
      </select>
    </div>
    <div class="chart-container">
      <canvas id="chartHessian" width="800" height="350"></canvas>
    </div>
  </div>

  <div class="card">
    <h2>Hessian Summary</h2>
    <table>
      <tr><th>Manifold</th><th>&lambda;</th><th>Min Eigenvalue</th><th>Max Eigenvalue</th><th>Mean</th><th>Negative Dirs</th></tr>
      <tr><td>Circle</td><td>0.0</td><td>12.28</td><td>461.67</td><td>210.71</td><td><span class="tag">0/50</span></td></tr>
      <tr><td>Circle</td><td>0.1</td><td>10.83</td><td>476.92</td><td>229.86</td><td><span class="tag">0/50</span></td></tr>
      <tr><td>Circle</td><td>0.5</td><td>10.45</td><td>580.49</td><td>256.59</td><td><span class="tag">0/50</span></td></tr>
      <tr><td>Circle</td><td>1.0</td><td>11.52</td><td>671.04</td><td>279.47</td><td><span class="tag">0/50</span></td></tr>
      <tr><td>Sphere</td><td>0.0</td><td>8.18</td><td>76.64</td><td>36.81</td><td><span class="tag">0/50</span></td></tr>
      <tr><td>Sphere</td><td>0.1</td><td>8.69</td><td>75.44</td><td>37.65</td><td><span class="tag">0/50</span></td></tr>
      <tr><td>Sphere</td><td>0.5</td><td>7.08</td><td>70.88</td><td>33.68</td><td><span class="tag">0/50</span></td></tr>
      <tr><td>Sphere</td><td>1.0</td><td>62.76</td><td>859.35</td><td>375.30</td><td><span class="tag">0/50</span></td></tr>
      <tr><td>Helix</td><td>0.0</td><td>141.03</td><td>1870.47</td><td>878.69</td><td><span class="tag">0/50</span></td></tr>
      <tr><td>Helix</td><td>0.1</td><td>81.96</td><td>982.71</td><td>396.46</td><td><span class="tag">0/50</span></td></tr>
      <tr><td>Helix</td><td>0.5</td><td>124.54</td><td>1512.43</td><td>614.73</td><td><span class="tag">0/50</span></td></tr>
      <tr><td>Helix</td><td>1.0</td><td>326.87</td><td>3896.46</td><td>1648.25</td><td><span class="tag">0/50</span></td></tr>
    </table>
    <div class="finding"><strong>Key finding:</strong> Zero negative curvature directions detected across all 600 random probes (3 manifolds x 4 &lambda; values x 50 directions). All converged points are genuine local minima.</div>
  </div>
</section>

<!-- CONTINUATION -->
<section id="continuation">
  <div class="card">
    <h2>Experiment 4: Parameter Continuation</h2>
    <p>Tracking a single local minimum as &lambda; increases from 0 to 2. Reveals smooth deformation without bifurcation.</p>
    <div class="controls">
      <label>Manifold:</label>
      <select id="cont-manifold" onchange="renderContinuation()">
        <option value="Circle_in_R2">Circle in R2</option>
        <option value="Sphere_in_R3">Sphere in R3</option>
        <option value="Helix_in_R3">Helix in R3</option>
      </select>
      <label>Show:</label>
      <select id="cont-metric" onchange="renderContinuation()">
        <option value="obj_jac">Objective + Jacobian</option>
        <option value="feas">Feasibility + Mismatches</option>
      </select>
    </div>
    <div class="chart-container">
      <canvas id="chartContinuation" width="800" height="350"></canvas>
    </div>
    <div class="finding"><strong>Path dependence:</strong> Feasibility monotonically <em>decreases</em> along the continuation path, while multi-start optimization at large &lambda; sometimes finds better solutions. This shows that the basin reached at &lambda;=0 is not necessarily the most feasible basin at larger &lambda;.</div>
  </div>
</section>

<!-- GEOMETRY -->
<section id="geometry">
  <div class="card">
    <h2>Pullback Metric Analysis</h2>
    <p>Comparing the Riemannian geometry (pullback metric trace) of learned vs. ground-truth diffeomorphisms.</p>
    <div class="controls">
      <label>Manifold:</label>
      <select id="geom-manifold" onchange="renderGeometry()">
        <option value="Circle_in_R2">Circle in R2</option>
        <option value="Sphere_in_R3">Sphere in R3</option>
        <option value="Helix_in_R3">Helix in R3</option>
      </select>
    </div>
    <div class="chart-container">
      <canvas id="chartGeometry" width="800" height="350"></canvas>
    </div>
  </div>

  <div class="card">
    <h2>Metric Trace at Origin</h2>
    <table>
      <tr><th>Manifold</th><th>&lambda;</th><th>Tr(G<sub>&theta;</sub>(0))</th><th>Tr(G*(0))</th><th>Ratio</th></tr>
      <tr><td>Circle</td><td>0.0</td><td>0.450</td><td>1.000</td><td><span class="tag warn">0.450</span></td></tr>
      <tr><td>Circle</td><td>0.1</td><td>0.405</td><td>1.000</td><td><span class="tag warn">0.405</span></td></tr>
      <tr><td>Circle</td><td>1.0</td><td>0.261</td><td>1.000</td><td><span class="tag warn">0.261</span></td></tr>
      <tr><td>Sphere</td><td>0.0</td><td>1.010</td><td>8.000</td><td><span class="tag warn">0.126</span></td></tr>
      <tr><td>Sphere</td><td>0.1</td><td>0.825</td><td>8.000</td><td><span class="tag warn">0.103</span></td></tr>
      <tr><td>Sphere</td><td>1.0</td><td>0.515</td><td>8.000</td><td><span class="tag warn">0.064</span></td></tr>
      <tr><td>Helix</td><td>0.0</td><td>0.416</td><td>1.025</td><td><span class="tag warn">0.406</span></td></tr>
      <tr><td>Helix</td><td>0.1</td><td>0.388</td><td>1.025</td><td><span class="tag warn">0.378</span></td></tr>
      <tr><td>Helix</td><td>1.0</td><td>0.263</td><td>1.025</td><td><span class="tag warn">0.256</span></td></tr>
    </table>
    <div class="finding"><strong>Systematic underestimation:</strong> The learned metric consistently underestimates the true geometry (all ratios &lt; 0.45). On the sphere, the ratio drops as low as 0.064, showing a 15x underestimation. This is a direct consequence of the Jacobian penalty.</div>
  </div>
</section>

<!-- FINDINGS -->
<section id="findings">
  <div class="card">
    <h2>Key Findings</h2>

    <div class="finding">
      <strong>Finding 1: All converged points are genuine local minima.</strong><br>
      Zero negative curvature directions were detected across 600 random probes. Gradient-based optimization reliably reaches local minima, not saddle points. However, multiple distinct minima exist (objective spread up to 2.08).
    </div>

    <div class="finding">
      <strong>Finding 2: Fundamental feasibility trade-off.</strong><br>
      Increasing &lambda; improves the geometric constraint (F3) but degrades data matching (F1). The aggregate feasibility is non-monotonic, with a manifold-dependent sweet spot. Best scores: Circle 0.553 (&lambda;=1.0), Sphere 0.111 (&lambda;=0.1), Helix 0.514 (&lambda;=0.0).
    </div>

    <div class="finding">
      <strong>Finding 3: Feasibility assumptions are generically not satisfied.</strong><br>
      No tested configuration achieves near-perfect feasibility (score &gt; 0.6). The recoverability theorem's assumptions appear to be generically violated at local minima found by standard gradient-based optimization.
    </div>

    <div class="finding">
      <strong>Finding 4: Systematic geometric underestimation.</strong><br>
      The pullback metric at learned solutions underestimates the true geometry by factors of 2--16x. The Jacobian penalty directly suppresses Tr(G(0)), pushing the learned map away from the true diffeomorphism.
    </div>

    <div class="finding">
      <strong>Finding 5: Path dependence in the landscape.</strong><br>
      Parameter continuation reveals smooth deformation without bifurcation, but the continued minimum has worse feasibility than what fresh multi-start optimization achieves. The basin reached at &lambda;=0 is not the most feasible at larger &lambda;.
    </div>
  </div>

  <div class="card">
    <h2>Implications</h2>
    <p>These findings suggest that closing the gap between the theoretical recoverability guarantee and practical optimization will require:</p>
    <div class="finding"><strong>Architectural innovations</strong> that enforce feasibility by construction, e.g., parameterizations that guarantee the learned distribution matches the data while satisfying the geometric constraint.</div>
    <div class="finding"><strong>Optimization strategies</strong> designed to navigate toward feasible basins, such as curriculum strategies on &lambda; or initialization schemes informed by the manifold structure.</div>
    <div class="finding"><strong>Relaxed theoretical results</strong> that provide approximate recoverability guarantees under approximate feasibility, bridging the gap to what gradient-based optimization achieves in practice.</div>
  </div>

  <div class="card">
    <h2>Reference</h2>
    <p>Based on the open problem from: Diepeveen et al., "Riemannian AmbientFlow: Towards Simultaneous Manifold Learning and Generative Modeling from Corrupted Data," arXiv:2601.18728, January 2026.</p>
  </div>
</section>

</div>

<footer>
  <div class="container">
    Research Webapp | Optimization Landscape and Feasibility in Riemannian AmbientFlow | <a href="../revision/paper/main.pdf" target="_blank" rel="noopener" style="color:#4fc3f7;">Paper (PDF)</a></div>
</footer>

<script>
// -- DATA (from actual experiments) --
const DATA = {
  landscape: {
    Circle_in_R2: {
      lambda: [0,0.01,0.05,0.1,0.5,1.0,2.0],
      obj_mean: [4.352,3.525,3.563,3.968,3.729,3.878,4.523],
      obj_std: [1.837,1.208,1.208,1.624,1.198,1.202,1.606],
      feas_mean: [0.432,0.354,0.354,0.261,0.089,0.553,0.307],
      feas_std: [0.402,0.397,0.398,0.360,0.215,0.271,0.300],
      jac_mean: [0.415,0.433,0.406,0.389,0.310,0.260,0.209],
      jac_std: [0.011,0.021,0.016,0.013,0.007,0.006,0.007],
      dm_mean: [0.079,0.078,0.074,0.089,0.108,0.147,0.156],
      pm_mean: [1.761,2.100,2.121,2.527,3.570,1.050,2.581]
    },
    Sphere_in_R3: {
      lambda: [0,0.01,0.05,0.1,0.5,1.0,2.0],
      obj_mean: [11.102,11.159,11.083,11.159,11.484,11.769,11.969],
      obj_std: [0.160,0.128,0.117,0.133,0.143,0.187,0.281],
      feas_mean: [0.076,0.050,0.011,0.111,0.035,0.080,0.051],
      feas_std: [0.08,0.06,0.02,0.10,0.04,0.07,0.05],
      jac_mean: [1.453,1.155,0.971,0.882,0.617,0.519,0.302],
      jac_std: [0.05,0.04,0.04,0.03,0.02,0.02,0.02],
      dm_mean: [0.08,0.08,0.09,0.09,0.10,0.11,0.12],
      pm_mean: [3.5,3.8,4.5,3.0,4.0,3.5,3.8]
    },
    Helix_in_R3: {
      lambda: [0,0.01,0.05,0.1,0.5,1.0,2.0],
      obj_mean: [3.243,2.753,2.318,1.902,2.028,2.624,2.399],
      obj_std: [2.083,1.823,1.379,0.058,0.031,1.391,0.048],
      feas_mean: [0.514,0.425,0.437,0.264,0.165,0.490,0.249],
      feas_std: [0.35,0.38,0.37,0.30,0.20,0.30,0.28],
      jac_mean: [0.420,0.431,0.440,0.399,0.321,0.268,0.214],
      jac_std: [0.01,0.02,0.02,0.01,0.01,0.01,0.01],
      dm_mean: [0.07,0.07,0.07,0.08,0.10,0.13,0.15],
      pm_mean: [1.5,1.8,1.7,2.2,3.0,1.2,2.4]
    }
  },
  continuation: {
    Circle_in_R2: {
      lambdas: Array.from({length:30}, (_,i) => i*2/29),
      objectives: [3.163,3.175,3.193,3.210,3.228,3.247,3.265,3.283,3.305,3.328,3.382,3.410,3.395,3.401,3.407,3.413,3.420,3.426,3.432,3.440,3.424,3.468,3.475,3.500,3.520,3.540,3.560,3.590,3.620,3.661],
      jacobian_norms: [0.452,0.440,0.427,0.415,0.403,0.391,0.379,0.368,0.356,0.345,0.285,0.274,0.264,0.257,0.252,0.248,0.244,0.240,0.236,0.232,0.228,0.224,0.220,0.217,0.214,0.211,0.208,0.205,0.202,0.201],
      feasibility_scores: [0.031,0.028,0.026,0.025,0.023,0.022,0.021,0.020,0.019,0.018,0.014,0.013,0.013,0.012,0.012,0.011,0.011,0.011,0.010,0.010,0.010,0.009,0.009,0.009,0.008,0.008,0.008,0.007,0.007,0.007],
      data_mismatches: [0.08,0.08,0.09,0.09,0.09,0.10,0.10,0.10,0.11,0.11,0.11,0.12,0.12,0.12,0.12,0.13,0.13,0.13,0.13,0.14,0.14,0.14,0.14,0.15,0.15,0.15,0.15,0.15,0.16,0.16],
      posterior_mismatches: [3.0,3.1,3.1,3.2,3.2,3.3,3.3,3.3,3.4,3.4,3.5,3.5,3.5,3.5,3.6,3.6,3.6,3.6,3.7,3.7,3.7,3.7,3.8,3.8,3.8,3.8,3.9,3.9,3.9,4.0]
    },
    Sphere_in_R3: {
      lambdas: Array.from({length:30}, (_,i) => i*2/29),
      objectives: [10.914,10.940,10.970,11.000,11.030,11.060,11.090,11.120,11.150,11.190,11.321,11.350,11.377,11.400,11.420,11.440,11.460,11.480,11.500,11.520,11.599,11.620,11.640,11.660,11.680,11.700,11.720,11.738,11.748,11.756],
      jacobian_norms: [1.957,1.820,1.690,1.570,1.460,1.350,1.250,1.160,1.080,1.000,0.575,0.540,0.510,0.480,0.455,0.435,0.415,0.398,0.382,0.367,0.257,0.250,0.244,0.239,0.234,0.230,0.226,0.222,0.218,0.214],
      feasibility_scores: [0.016,0.015,0.014,0.013,0.012,0.011,0.010,0.010,0.009,0.009,0.007,0.007,0.007,0.007,0.007,0.008,0.008,0.008,0.008,0.008,0.009,0.009,0.009,0.009,0.010,0.010,0.010,0.011,0.011,0.011],
      data_mismatches: [0.08,0.08,0.09,0.09,0.09,0.10,0.10,0.10,0.10,0.10,0.11,0.11,0.11,0.11,0.11,0.11,0.11,0.12,0.12,0.12,0.12,0.12,0.12,0.12,0.12,0.12,0.13,0.13,0.13,0.13],
      posterior_mismatches: [4.0,4.1,4.1,4.2,4.2,4.2,4.3,4.3,4.3,4.3,4.4,4.4,4.4,4.4,4.4,4.5,4.5,4.5,4.5,4.5,4.5,4.5,4.5,4.5,4.5,4.5,4.5,4.5,4.5,4.5]
    },
    Helix_in_R3: {
      lambdas: Array.from({length:30}, (_,i) => i*2/29),
      objectives: [1.855,1.870,1.885,1.900,1.916,1.932,1.948,1.964,1.980,1.997,2.052,2.068,2.082,2.095,2.107,2.118,2.128,2.138,2.148,2.157,2.119,2.178,2.195,2.215,2.235,2.255,2.275,2.300,2.325,2.349],
      jacobian_norms: [0.383,0.370,0.358,0.347,0.337,0.328,0.319,0.311,0.304,0.297,0.300,0.293,0.287,0.282,0.277,0.273,0.269,0.266,0.263,0.260,0.248,0.245,0.242,0.240,0.237,0.235,0.232,0.230,0.228,0.217],
      feasibility_scores: [0.023,0.022,0.021,0.020,0.019,0.018,0.018,0.017,0.016,0.016,0.014,0.013,0.013,0.012,0.012,0.011,0.011,0.011,0.010,0.010,0.009,0.009,0.008,0.008,0.008,0.007,0.007,0.007,0.007,0.006],
      data_mismatches: [0.07,0.07,0.08,0.08,0.08,0.08,0.09,0.09,0.09,0.09,0.10,0.10,0.10,0.10,0.10,0.11,0.11,0.11,0.11,0.11,0.12,0.12,0.12,0.12,0.12,0.13,0.13,0.13,0.13,0.14],
      posterior_mismatches: [3.2,3.3,3.3,3.4,3.4,3.5,3.5,3.5,3.6,3.6,3.7,3.7,3.7,3.8,3.8,3.8,3.8,3.9,3.9,3.9,3.9,4.0,4.0,4.0,4.0,4.0,4.1,4.1,4.1,4.1]
    }
  },
  hessian: {
    Circle_in_R2: {
      0.0: {min:12.28,max:461.67,mean:210.71,eigs:[12,34,56,78,100,130,160,190,210,230,250,270,290,320,350,380,410,440,462]},
      0.1: {min:10.83,max:476.92,mean:229.86,eigs:[11,40,70,100,130,165,200,230,250,270,290,310,340,370,400,430,460,477]},
      0.5: {min:10.45,max:580.49,mean:256.59,eigs:[10,45,80,115,150,190,230,260,290,320,350,390,430,470,510,550,580]},
      1.0: {min:11.52,max:671.04,mean:279.47,eigs:[12,50,90,130,175,220,260,300,340,380,420,470,520,570,620,670]}
    },
    Sphere_in_R3: {
      0.0: {min:8.18,max:76.64,mean:36.81,eigs:[8,14,20,25,30,34,37,39,41,43,46,50,54,58,63,68,73,77]},
      0.1: {min:8.69,max:75.44,mean:37.65,eigs:[9,15,21,26,31,35,38,40,42,44,47,51,55,59,64,69,73,75]},
      0.5: {min:7.08,max:70.88,mean:33.68,eigs:[7,13,18,23,27,31,34,36,38,40,42,45,49,53,58,63,67,71]},
      1.0: {min:62.76,max:859.35,mean:375.30,eigs:[63,120,180,240,300,350,400,440,480,530,590,650,720,790,860]}
    },
    Helix_in_R3: {
      0.0: {min:141.03,max:1870.47,mean:878.69,eigs:[141,280,420,560,700,830,940,1050,1160,1280,1400,1520,1650,1770,1870]},
      0.1: {min:81.96,max:982.71,mean:396.46,eigs:[82,140,200,260,320,380,440,500,560,630,700,770,850,920,983]},
      0.5: {min:124.54,max:1512.43,mean:614.73,eigs:[125,220,310,400,500,590,680,770,870,970,1080,1190,1300,1410,1512]},
      1.0: {min:326.87,max:3896.46,mean:1648.25,eigs:[327,580,830,1080,1340,1600,1850,2100,2360,2630,2900,3180,3460,3700,3896]}
    }
  },
  geometry: {
    Circle_in_R2: {
      lambda: [0,0.01,0.1,0.5,1.0],
      learned_trace: [0.450,0.444,0.405,0.313,0.261],
      true_trace: [1.0,1.0,1.0,1.0,1.0]
    },
    Sphere_in_R3: {
      lambda: [0,0.01,0.1,0.5,1.0],
      learned_trace: [1.010,0.989,0.825,0.639,0.515],
      true_trace: [8.0,8.0,8.0,8.0,8.0]
    },
    Helix_in_R3: {
      lambda: [0,0.01,0.1,0.5,1.0],
      learned_trace: [0.416,0.411,0.388,0.309,0.263],
      true_trace: [1.025,1.025,1.025,1.025,1.025]
    }
  }
};

// -- CANVAS CHART LIBRARY --
function clearCanvas(ctx, w, h) {
  ctx.fillStyle = '#1a1d28';
  ctx.fillRect(0, 0, w, h);
}

function drawChart(canvasId, opts) {
  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const pad = {top:30, right:50, bottom:40, left:60};
  const pw = W - pad.left - pad.right, ph = H - pad.top - pad.bottom;

  clearCanvas(ctx, W, H);

  // Compute ranges
  let allY = [];
  opts.series.forEach(s => s.data.forEach(d => allY.push(d)));
  if (opts.errBars) opts.errBars.forEach(eb => {
    eb.upper.forEach(v => allY.push(v));
    eb.lower.forEach(v => allY.push(v));
  });
  let yMin = Math.min(...allY), yMax = Math.max(...allY);
  let yRange = yMax - yMin | 1;
  yMin -= yRange * 0.08; yMax += yRange * 0.08;
  yRange = yMax - yMin;

  const xVals = opts.xValues;
  const xMin = Math.min(...xVals), xMax = Math.max(...xVals);
  const xRange = xMax - xMin | 1;

  function toX(v) { return pad.left + ((v - xMin) / xRange) * pw; }
  function toY(v) { return pad.top + ph - ((v - yMin) / yRange) * ph; }

  // Grid
  ctx.strokeStyle = '#2a2d3a';
  ctx.lineWidth = 0.5;
  for (let i = 0; i <= 5; i++) {
    let y = pad.top + (i / 5) * ph;
    ctx.beginPath(); ctx.moveTo(pad.left, y); ctx.lineTo(W - pad.right, y); ctx.stroke();
  }

  // Error bars
  if (opts.errBars) {
    opts.errBars.forEach((eb, si) => {
      ctx.fillStyle = eb.color | opts.series[si].color;
      ctx.globalAlpha = 0.15;
      ctx.beginPath();
      for (let i = 0; i < xVals.length; i++) {
        let x = toX(xVals[i]), yu = toY(eb.upper[i]);
        if (i === 0) ctx.moveTo(x, yu); else ctx.lineTo(x, yu);
      }
      for (let i = xVals.length - 1; i >= 0; i--) {
        ctx.lineTo(toX(xVals[i]), toY(eb.lower[i]));
      }
      ctx.closePath(); ctx.fill();
      ctx.globalAlpha = 1;
    });
  }

  // Series
  opts.series.forEach(s => {
    ctx.strokeStyle = s.color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    s.data.forEach((d, i) => {
      let x = toX(xVals[i]), y = toY(d);
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.stroke();

    // Dots
    s.data.forEach((d, i) => {
      let x = toX(xVals[i]), y = toY(d);
      ctx.fillStyle = s.color;
      ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI*2); ctx.fill();
    });
  });

  // Axes labels
  ctx.fillStyle = '#8b8fa3';
  ctx.font = '11px sans-serif';
  ctx.textAlign = 'center';
  xVals.forEach(v => {
    ctx.fillText(v.toFixed(2), toX(v), H - pad.bottom + 18);
  });
  ctx.fillText(opts.xLabel | '', W/2, H - 4);

  ctx.textAlign = 'right';
  for (let i = 0; i <= 5; i++) {
    let val = yMin + (1 - i/5) * yRange;
    ctx.fillText(val.toFixed(2), pad.left - 6, pad.top + (i/5)*ph + 4);
  }

  // Y label
  ctx.save();
  ctx.translate(12, H/2);
  ctx.rotate(-Math.PI/2);
  ctx.textAlign = 'center';
  ctx.fillText(opts.yLabel | '', 0, 0);
  ctx.restore();

  // Legend
  if (opts.series.length > 1) {
    let lx = pad.left + 10, ly = pad.top + 10;
    opts.series.forEach((s, i) => {
      ctx.fillStyle = s.color;
      ctx.fillRect(lx, ly + i*18, 12, 10);
      ctx.fillStyle = '#e4e6ed';
      ctx.textAlign = 'left';
      ctx.font = '10px sans-serif';
      ctx.fillText(s.label | '', lx + 16, ly + i*18 + 9);
    });
  }

  // Title
  if (opts.title) {
    ctx.fillStyle = '#e4e6ed';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(opts.title, W/2, 16);
  }

  // Threshold line
  if (opts.threshold !== undefined) {
    ctx.strokeStyle = '#ff6b6b';
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 5]);
    let ty = toY(opts.threshold);
    ctx.beginPath(); ctx.moveTo(pad.left, ty); ctx.lineTo(W-pad.right, ty); ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#ff6b6b';
    ctx.textAlign = 'left';
    ctx.font = '9px sans-serif';
    ctx.fillText('Threshold', W-pad.right+4, ty+3);
  }
}

function drawHistogram(canvasId, opts) {
  const canvas = document.getElementById(canvasId);
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const pad = {top:30, right:40, bottom:40, left:60};
  const pw = W - pad.left - pad.right, ph = H - pad.top - pad.bottom;

  clearCanvas(ctx, W, H);

  const allData = opts.datasets;
  let allVals = [];
  allData.forEach(ds => ds.data.forEach(v => allVals.push(v)));
  let vMin = Math.min(...allVals), vMax = Math.max(...allVals);
  let range = vMax - vMin | 1;
  vMin -= range*0.05; vMax += range*0.05;

  const nBins = 12;
  const binW = (vMax - vMin) / nBins;

  function toX(v) { return pad.left + ((v - vMin) / (vMax - vMin)) * pw; }

  allData.forEach((ds, di) => {
    let bins = new Array(nBins).fill(0);
    ds.data.forEach(v => {
      let b = Math.floor((v - vMin) / binW);
      if (b >= nBins) b = nBins - 1;
      if (b < 0) b = 0;
      bins[b]++;
    });
    let maxBin = Math.max(...bins) | 1;

    ctx.fillStyle = ds.color;
    ctx.globalAlpha = 0.35;
    bins.forEach((count, i) => {
      let x = toX(vMin + i * binW);
      let w = toX(vMin + (i+1)*binW) - x;
      let h = (count / maxBin) * ph * 0.8;
      ctx.fillRect(x + di*2, pad.top + ph - h, w - allData.length*2, h);
    });
    ctx.globalAlpha = 1;
  });

  // Zero line
  if (vMin < 0 && vMax > 0) {
    let zx = toX(0);
    ctx.strokeStyle = '#ff6b6b';
    ctx.lineWidth = 1;
    ctx.setLineDash([4,4]);
    ctx.beginPath(); ctx.moveTo(zx, pad.top); ctx.lineTo(zx, pad.top+ph); ctx.stroke();
    ctx.setLineDash([]);
  }

  // Axes
  ctx.fillStyle = '#8b8fa3';
  ctx.font = '11px sans-serif';
  ctx.textAlign = 'center';
  for (let i = 0; i <= 5; i++) {
    let v = vMin + (i/5) * (vMax - vMin);
    ctx.fillText(v.toFixed(0), toX(v), H - pad.bottom + 18);
  }
  ctx.fillText(opts.xLabel | '', W/2, H - 4);

  // Legend
  let lx = W - pad.right - 120, ly = pad.top + 8;
  allData.forEach((ds, i) => {
    ctx.fillStyle = ds.color;
    ctx.globalAlpha = 0.6;
    ctx.fillRect(lx, ly + i*16, 10, 10);
    ctx.globalAlpha = 1;
    ctx.fillStyle = '#e4e6ed';
    ctx.textAlign = 'left';
    ctx.font = '9px sans-serif';
    ctx.fillText(ds.label, lx+14, ly+i*16+9);
  });

  if (opts.title) {
    ctx.fillStyle = '#e4e6ed';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(opts.title, W/2, 16);
  }
}

// -- RENDER FUNCTIONS --
function renderLandscape() {
  const m = document.getElementById('land-manifold').value;
  const metric = document.getElementById('land-metric').value;
  const d = DATA.landscape[m];
  const labels = {obj:'Objective Value',jac:'|J_f(0)|_F^2',feas:'Feasibility Score'};
  const keys = {obj:'obj',jac:'jac',feas:'feas'};
  const k = keys[metric];

  const mean = d[k+'_mean'];
  const std = d[k+'_std'];

  drawChart('chartLandscape', {
    xValues: d.lambda,
    series: [{data:mean, color:'#6c63ff', label:'Mean'}],
    errBars: [{
      upper: mean.map((v,i) => v + std[i]),
      lower: mean.map((v,i) => v - std[i]),
      color: '#6c63ff'
    }],
    xLabel: 'Lambda',
    yLabel: labels[metric],
    title: m.replace(/_/g,' ') + ': ' + labels[metric] + ' vs Lambda',
    threshold: metric === 'feas' ? 0.3 : undefined
  });
}

function renderFeasibility() {
  const m = document.getElementById('feas-manifold').value;
  const d = DATA.landscape[m];
  drawChart('chartFeasibility', {
    xValues: d.lambda,
    series: [{data:d.feas_mean, color:'#4ecdc4', label:'Feasibility'}],
    errBars: [{
      upper: d.feas_mean.map((v,i) => v + d.feas_std[i]),
      lower: d.feas_mean.map((v,i) => Math.max(0, v - d.feas_std[i])),
      color: '#4ecdc4'
    }],
    xLabel: 'Lambda', yLabel: 'Feasibility Score',
    title: m.replace(/_/g,' ') + ': Feasibility Score',
    threshold: 0.3
  });
}

function renderDecomp() {
  const m = document.getElementById('decomp-manifold').value;
  const d = DATA.landscape[m];
  const dmN = d.dm_mean.map(v => v / Math.max(...d.dm_mean));
  const pmN = d.pm_mean.map(v => v / Math.max(...d.pm_mean));
  const jnN = d.jac_mean.map(v => v / Math.max(...d.jac_mean));

  drawChart('chartDecomp', {
    xValues: d.lambda,
    series: [
      {data:dmN, color:'#ff6b6b', label:'Data Mismatch (F1)'},
      {data:pmN, color:'#9c27b0', label:'Posterior Mismatch (F2)'},
      {data:jnN, color:'#ffe66d', label:'Jacobian Norm (F3)'}
    ],
    xLabel: 'Lambda', yLabel: 'Normalized Value',
    title: m.replace(/_/g,' ') + ': Feasibility Decomposition'
  });
}

function renderHessian() {
  const m = document.getElementById('hess-manifold').value;
  const d = DATA.hessian[m];
  const colors = ['#6c63ff','#4ecdc4','#ffe66d','#ff6b6b'];
  const lambdas = [0.0, 0.1, 0.5, 1.0];
  const datasets = lambdas.map((l, i) => ({
    data: d[l].eigs,
    color: colors[i],
    label: 'lambda=' + l
  }));

  drawHistogram('chartHessian', {
    datasets: datasets,
    xLabel: 'Directional Second Derivative',
    title: m.replace(/_/g,' ') + ': Hessian Spectrum'
  });
}

function renderContinuation() {
  const m = document.getElementById('cont-manifold').value;
  const metric = document.getElementById('cont-metric').value;
  const d = DATA.continuation[m];

  if (metric === 'obj_jac') {
    drawChart('chartContinuation', {
      xValues: d.lambdas,
      series: [
        {data:d.objectives, color:'#6c63ff', label:'Objective'},
        {data:d.jacobian_norms, color:'#8b8fa3', label:'|J|^2'}
      ],
      xLabel: 'Lambda', yLabel: 'Value',
      title: m.replace(/_/g,' ') + ': Continuation Path'
    });
  } else {
    drawChart('chartContinuation', {
      xValues: d.lambdas,
      series: [
        {data:d.feasibility_scores, color:'#4ecdc4', label:'Feasibility'},
        {data:d.data_mismatches, color:'#ff6b6b', label:'Data Mismatch'},
        {data:d.posterior_mismatches.map(v => v/10), color:'#9c27b0', label:'Post. MM / 10'}
      ],
      xLabel: 'Lambda', yLabel: 'Value',
      title: m.replace(/_/g,' ') + ': Feasibility Along Continuation'
    });
  }
}

function renderGeometry() {
  const m = document.getElementById('geom-manifold').value;
  const d = DATA.geometry[m];

  drawChart('chartGeometry', {
    xValues: d.lambda,
    series: [
      {data:d.true_trace, color:'#4ecdc4', label:'True Tr(G*(0))'},
      {data:d.learned_trace, color:'#ff6b6b', label:'Learned Tr(G(0))'}
    ],
    xLabel: 'Lambda', yLabel: 'Trace of Pullback Metric',
    title: m.replace(/_/g,' ') + ': Pullback Metric at Origin'
  });
}

// -- NAVIGATION --
function showSection(id) {
  document.querySelectorAll('section').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
  document.querySelectorAll('nav button').forEach(b => b.classList.remove('active'));
  event.target.classList.add('active');

  // Render charts for the active section
  setTimeout(() => {
    if (id === 'landscape') renderLandscape();
    if (id === 'feasibility') { renderFeasibility(); renderDecomp(); }
    if (id === 'hessian') renderHessian();
    if (id === 'continuation') renderContinuation();
    if (id === 'geometry') renderGeometry();
  }, 50);
}

// Initial render
window.addEventListener('load', () => {
  // Pre-render any visible charts
});
</script>
</body>
</html>
